# -*- coding: utf-8 -*-
"""Main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D2mnezuln5CZVIBrjidLmehWIyp3UOaS
"""

!pip install openai PyPDF2 python-dotenv

pip install google-generativeai

!pip install -q google-generativeai

MainAPI = "" #Enter your secret API key

import google.generativeai as genai

genai.configure(api_key=MainAPI)

for model in genai.list_models():
    print(model.name)

import google.generativeai as genai

# Set your Gemini API key
genai.configure(api_key=MainAPI)

# Create the model instance (make sure it's v1!)
model = genai.GenerativeModel("models/gemini-2.0-flash")

# Call the generation method correctly
def generate_quiz_with_gemini(text):
    prompt = f"""
    Generate 5 multiple choice questions from the following content:
    \"\"\"{text}\"\"\"
    Format:
    Q: Question?
    a) Option A
    b) Option B
    c) Option C
    d) Option D
    Answer: [correct option]
    """
    response = model.generate_content(prompt)
    return response.text

notes_text = """
Nuclear Fission is the process of Dismentaling of a havier Nuclei into lighter Nucleai realesing huge ammount of energy. Whereas
Nuclear Fusion involves Lighter nuclei to join together to form haviour nuclei realising huge energy
"""

quiz = generate_quiz_with_gemini(notes_text)
print(quiz)

import google.generativeai as genai

# Replace this with your regenerated key (keep it private!)
API_KEY = MainAPI

# Configure Gemini
genai.configure(api_key=API_KEY)

def generate_prompt_for_topic(topic: str):
    try:
        model = genai.GenerativeModel("models/gemini-2.0-flash")

        prompt = f"""
You are a prompt engineer assistant.

Your task is to create clear and powerful prompts for a generative AI that helps students learn through flashcards and quizzes.

Given a topic or raw text, generate a prompt that can be used to:
1. Create multiple-choice questions with 4 options
2. Identify the correct answer
3. Format the result in a readable format

Respond with only the generated prompt in plain text.

Here is the topic:
\"{topic}\"
"""

        # Use stream=True to handle big output
        response = model.generate_content(prompt, stream=True)

        print("üîß Generated Prompt:\n")
        for chunk in response:
            if chunk.text:  # Only print if there's actual content
                print(chunk.text, end="")

    except Exception as e:
        print("\n‚ùå Error during generation:", e)

# Example usage
generate_prompt_for_topic("Nuclear Fusion and Radioactivity")

pip install python-dotenv

import google.generativeai as genai

# ‚úÖ Paste your key here (keep it private in real apps)
genai.configure(api_key=MainAPI)

# ‚úÖ Choose a valid model
model = genai.GenerativeModel("models/gemini-2.0-flash")

# ‚úÖ Create a prompt
prompt = "Create 8 flashcard-style multiple-choice questions about the Nuclear Fusion and Radioactivity."

try:
    response = model.generate_content(prompt, stream=True)

    print("‚úÖ Output:\n")
    for chunk in response:
        # Handle only chunks that have text content
        if hasattr(chunk, 'text') and chunk.text:
            print(chunk.text, end="")

except Exception as e:
    print(f"‚ùå Error: {e}")

import google.generativeai as genai

# ‚úÖ Replace with your actual key
genai.configure(api_key=MainAPI)

# ‚úÖ Use a verified working model
model = genai.GenerativeModel("models/gemini-2.0-flash")

prompt = """Generate 3 multiple-choice questions about the RA.
Each question should have options A, B, C, D and include the correct answer.

Format:
Question: ...
A) ...
B) ...
C) ...
D) ...
Correct Answer: ...
"""

try:
    response = model.generate_content(prompt)
    print("‚úÖ Output:\n")
    print(response.text)
except Exception as e:
    print(f"‚ùå Error: {e}")

def generate_mcqs(topic: str):
    prompt = f"""Generate 5 multiple-choice questions about the topic "{topic}".
Each question must have 4 options (A, B, C, D), and clearly indicate the correct answer.

Format:
Question: ...
A) ...
B) ...
C) ...
D) ...
Correct Answer: ...
"""

    model = genai.GenerativeModel("models/gemini-2.0-flash")
    response = model.generate_content(prompt)
    return response.text

notes = "The process of Nuclear Fission and Nuclear Fusion, are two of the most important sub-entities of Nuclear Reactions"
questions = generate_mcqs(notes)
print(questions)

topic = "Nuclear Fusion and Fission"  # ‚úÖ Define your topic

prompt = f"""Generate flashcards for the topic "{topic}".
Each flashcard should have a question and a short answer.

Format:
Q: ...
A: ...
"""

model = genai.GenerativeModel("models/gemini-2.0-flash")
response = model.generate_content(prompt)
print(response.text)

def generate_flashcards(topic):
    prompt = f"""Generate flashcards for the topic "{topic}".
Each flashcard should have a question and a short answer.

Format:
Q: ...
A: ...
"""

    model = genai.GenerativeModel("models/gemini-2.0-flash")
    response = model.generate_content(prompt)
    return response.text

print(generate_flashcards("PROBLEMS OF NUCLEAR FUSION REACTIONS"))

!pip install python-docx fpdf

from fpdf import FPDF

def save_as_pdf(content, filename="flashcards.pdf"):
    pdf = FPDF()
    pdf.add_page()

    # Add Unicode-supporting font
    font_path = "'/Volumes/Extreme SSD/untitled folder 2/Gemi'"  # Common on Colab/Linux
    if not os.path.exists(font_path):
        raise FileNotFoundError("DejaVuSans.ttf not found. Make sure the font file exists.")

    pdf.add_font("DejaVu", "", font_path, uni=True)
    pdf.set_font("DejaVu", size=12)

    for line in content.strip().split("\n"):
        pdf.multi_cell(0, 10, txt=line)

    pdf.output(filename)

# Download DejaVuSans.ttf and save it locally
!wget -q https://github.com/dejavu-fonts/dejavu-fonts/blob/version_2_37/ttf/DejaVuSans.ttf?raw=true -O DejaVuSans.ttf

font_path = "DejaVuSans.ttf"

#!curl -q https://github.com/dejavu-fonts/dejavu-fonts/raw/version_2_37/ttf/DejaVuSans.ttf -O DejaVuSans.ttf

# import os
# from fpdf import FPDF
# from docx import Document
# import google.generativeai as genai

# # Step 1: Generate Flashcards
# def generate_flashcards(topic):
#     prompt = f"""Generate flashcards for the topic "{topic}".
# Each flashcard should have a question and a short answer.

# Format:
# Q: ...
# A: ...
# """
#     model = genai.GenerativeModel("models/gemini-2.0-flash")
#     response = model.generate_content(prompt)
#     return response.text

# # Step 2: Save as .txt
# def save_as_txt(content, filename="flashcards.txt"):
#     with open(filename, "w", encoding="utf-8") as f:
#         f.write(content)

# # Step 3: Save as .docx
# def save_as_docx(content, filename="flashcards.docx"):
#     doc = Document()
#     for line in content.strip().split("\n"):
#         doc.add_paragraph(line)
#     doc.save(filename)

# # Step 4: Save as .pdf

# def save_as_pdf(content, filename="flashcards.pdf"):
#     font_path = "DejaVuSans.ttf"

#     # Download font if missing
#     if not os.path.exists(font_path):
#         !wget -q https://github.com/dejavu-fonts/dejavu-fonts/raw/version_2_37/ttf/DejaVuSans.ttf -O DejaVuSans.ttf

#     pdf = FPDF()
#     pdf.add_page()
#     pdf.add_font("DejaVu", "", font_path, uni=True)
#     pdf.set_font("DejaVu", size=12)

#     for line in content.strip().split("\n"):
#         pdf.multi_cell(0, 10, txt=line)

#     pdf.output(filename)
# # Run Everything
# if __name__ == "__main__":
#     genai.configure(api_key=MainAPI)  # Replace with your Gemini API key

#     topic = "Photosynthesis and how it works"
#     flashcards = generate_flashcards(topic)

#     save_as_txt(flashcards)
#     save_as_docx(flashcards)
#     save_as_pdf(flashcards)

#     print("‚úÖ Flashcards exported as TXT, DOCX, and PDF.")

!rm -f DejaVuSans.ttf

import requests

url = "https://github.com/dejavu-fonts/dejavu-fonts/raw/version_2_37/ttf/DejaVuSans.ttf"
response = requests.get(url)

with open("DejaVuSans.ttf", "wb") as f:
    f.write(response.content)

from fpdf import FPDF

def save_as_pdf(content, filename="flashcards.pdf"):
    font_path = "DejaVuSans.ttf"
    if not os.path.exists(font_path):
        raise FileNotFoundError("DejaVuSans.ttf not found.")

    pdf = FPDF()
    pdf.add_page()
    pdf.add_font("DejaVu", "", font_path, uni=True)
    pdf.set_font("DejaVu", size=12)

    for line in content.strip().split("\n"):
        pdf.multi_cell(0, 10, txt=line)

    pdf.output(filename)

genai.configure(api_key=MainAPI)  # Must be called before using the model

response = model.generate_content(prompt)

if not response.candidates:
    print("‚ùå No candidates returned. Likely an API or prompt issue.")
else:
    print("‚úÖ Response received.")
    print(response.text)

import os
from fpdf import FPDF
from docx import Document
import google.generativeai as genai

# Configure API
genai.configure(api_key=MainAPI)

# Generate flashcards using Gemini
def generate_flashcards(topic):
    prompt = f"""Generate flashcards for the topic "{topic}".
Each flashcard should have a question and a short answer.

Format:
Q: [question]
A: [answer]

Generate 5-10 flashcards."""
    model = genai.GenerativeModel("gemini-2.0-flash")
    response = model.generate_content(prompt)
    return response.text

# Save as TXT
def save_as_txt(content, filename="flashcards.txt"):
    with open(filename, "w", encoding="utf-8") as f:
        f.write(content)

# Save as DOCX
def save_as_docx(content, filename="flashcards.docx"):
    doc = Document()
    for line in content.split("\n"):
        doc.add_paragraph(line)
    doc.save(filename)

# Save as PDF
def save_as_pdf(content, filename="flashcards.pdf"):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_auto_page_break(auto=True, margin=15)

    # Use a built-in font to avoid TTF issues
    pdf.set_font("Arial", size=12)

    for line in content.split("\n"):
        pdf.cell(200, 10, txt=line.encode("latin-1", "replace").decode("latin-1"), ln=True)

    pdf.output(filename)

# Main
if __name__ == "__main__":
    topic = "Nuclear Fusion and Nuclear Fission"
    flashcards = generate_flashcards(topic)

    save_as_txt(flashcards)
    save_as_docx(flashcards)
    save_as_pdf(flashcards)

    print("‚úÖ Flashcards saved as TXT, DOCX, and PDF.")

import os
from docx import Document
from fpdf import FPDF
import google.generativeai as genai

# ‚úÖ Step 1: Configure API
genai.configure(api_key=MainAPI)  # Replace with your actual Gemini API key

# ‚úÖ Step 2: Generate Flashcards
def generate_flashcards(topic):
    model = genai.GenerativeModel("gemini-2.0-flash")
    prompt = f"""Generate 5 flashcards on the topic "{topic}".
Each flashcard should follow this format:

Q: [Question]
A: [Answer]

Keep answers short and helpful for quick revision.
"""
    response = model.generate_content(prompt)
    return response.text if response and response.text else "No flashcards generated."

# ‚úÖ Step 3: Save as Text File
def save_as_txt(content, filename="flashcards.txt"):
    with open(filename, "w", encoding="utf-8") as f:
        f.write(content)

# ‚úÖ Step 4: Save as Word File
def save_as_docx(content, filename="flashcards.docx"):
    doc = Document()
    for line in content.strip().split("\n"):
        doc.add_paragraph(line)
    doc.save(filename)

# ‚úÖ Step 5: Save as PDF
def save_as_pdf(content, filename="flashcards.pdf"):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    for line in content.strip().split("\n"):
        pdf.cell(200, 10, txt=line, ln=True)
    pdf.output(filename)

# ‚úÖ Step 6: Run everything
if __name__ == "__main__":
    topic = "Nuclear Fusion and Nuclear Fission"
    flashcards = generate_flashcards(topic)

    save_as_txt(flashcards)
    save_as_docx(flashcards)
    save_as_pdf(flashcards)

    print("‚úÖ Flashcards saved as TXT, DOCX, and PDF.")

!pip install google.colab

from google.colab import files

files.download("flashcards.txt")
files.download("flashcards.docx")
files.download("flashcards.pdf")

import google.generativeai as genai

# Configure API Key
genai.configure(api_key=MainAPI)

# Load model
model = genai.GenerativeModel("gemini-2.0-flash")

def generate_mcqs(topic):
    prompt = f"""
    Create 5 multiple-choice questions on the topic: "{topic}".
    Each question should have 4 options labeled A, B, C, D.
    Also, provide the correct answer (only the letter).
    Format:
    Question: ...
    A) ...
    B) ...
    C) ...
    D) ...
    Correct Answer: ...
    """
    response = model.generate_content(prompt)
    return response.text

# Example
topic = "Famous cities all around the world"
questions_text = generate_mcqs(topic)
print(questions_text)

import google.generativeai as genai

# Configure your Gemini API key
genai.configure(api_key=MainAPI)

def generate_mcqs(topic):
    prompt = f"""
Generate 5 multiple-choice questions based on the topic "{topic}". Each question should have 4 options (A, B, C, D) and clearly mention the correct answer in this format:

Question: ...
A) ...
B) ...
C) ...
D) ...
Correct Answer: ...
"""
    model = genai.GenerativeModel("gemini-2.0-flash")
    response = model.generate_content(prompt)
    return response.text

from IPython.display import display, clear_output
import time
import ipywidgets as widgets

def run_quiz(questions_text):
    # Split questions
    questions = questions_text.strip().split("Question: ")[1:]  # skip first empty item

    score = 0

    for q in questions:
        clear_output(wait=True)

        lines = q.strip().splitlines()
        question_text = lines[0]
        options = lines[1:5]
        correct_line = [line for line in lines if "Correct Answer:" in line][0]
        correct_option = correct_line.split(":")[-1].strip()

        print("‚è≥ You have 15 seconds for this question:")
        print("\n" + question_text)
        for opt in options:
            print(opt)

        btns = [widgets.Button(description=opt[0], layout=widgets.Layout(width="60px")) for opt in options]
        answer_chosen = widgets.Output()

        def on_click(btn):
            nonlocal score
            chosen = btn.description
            if chosen == correct_option:
                score += 1
            answer_chosen.clear_output()
            with answer_chosen:
                print("‚úÖ" if chosen == correct_option else "‚ùå", f"Correct Answer: {correct_option}")

        for btn in btns:
            btn.on_click(on_click)
        display(widgets.HBox(btns))
        display(answer_chosen)
        time.sleep(15)

    print(f"\nüèÅ Quiz Completed! Your Score: {score}/{len(questions)}")

import google.generativeai as genai
from IPython.display import display, clear_output
import ipywidgets as widgets
import time
import threading

# Configure your Gemini API key
genai.configure(api_key=MainAPI)

def generate_mcqs(topic):
    prompt = f"""
Generate 5 multiple-choice questions based on the topic "{topic}". Each question should have 4 options (A, B, C, D) and clearly mention the correct answer in this format:

Question: ...
A) ...
B) ...
C) ...
D) ...
Correct Answer: ...
"""
    model = genai.GenerativeModel("gemini-1.5-flash")  # Use "gemini-1.5-flash" or latest
    response = model.generate_content(prompt)
    return response.text


def run_quiz(questions_text):
    questions = questions_text.strip().split("Question: ")[1:]

    score = 0
    total = len(questions)

    for i, q in enumerate(questions):
        clear_output(wait=True)

        lines = q.strip().splitlines()
        question_text = lines[0]
        options = lines[1:5]
        correct_line = [line for line in lines if "Correct Answer:" in line][0]
        correct_option = correct_line.split(":")[-1].strip()

        print(f"üß† Question {i+1}/{total}")
        print(question_text)

        radio = widgets.RadioButtons(
            options=options,
            layout={'width': 'max-content'},
            description='',
            disabled=False
        )

        submit_button = widgets.Button(description="Submit Answer")
        output = widgets.Output()

        timer_label = widgets.Label(value="‚è≥ Time left: 15s")

        box = widgets.VBox([timer_label, radio, submit_button, output])
        display(box)

        # Timer
        time_up = threading.Event()

        def countdown():
            for t in range(15, 0, -1):
                timer_label.value = f"‚è≥ Time left: {t}s"
                time.sleep(1)
                if time_up.is_set():
                    return
            timer_label.value = "‚è∞ Time's up!"
            submit_button.disabled = True
            radio.disabled = True
            with output:
                print("‚ùå Time's up! No answer submitted.")

        def on_submit(b):
            time_up.set()
            submit_button.disabled = True
            radio.disabled = True
            selected = radio.value
            chosen_option = selected.split(")")[0].strip()

            nonlocal score
            if chosen_option == correct_option:
                score += 1
                with output:
                    print("‚úÖ Correct!")
            else:
                with output:
                    print(f"‚ùå Incorrect! Correct answer was: {correct_option}")

        submit_button.on_click(on_submit)

        # Start timer
        thread = threading.Thread(target=countdown)
        thread.start()

        # Wait until submit or time up
        while thread.is_alive():
            time.sleep(0.1)

        time.sleep(2)

    clear_output()
    print(f"\nüèÅ Quiz Completed! Your Score: {score}/{total}")

# Run the quiz
topic = "Nuclear Fusion and Nuclear Fission"
questions = generate_mcqs(topic)
run_quiz(questions)

topic = "Nuclear Fusion and Nuclear Fission"
questions = generate_mcqs(topic)
run_quiz(questions)

def generate_mcq_prompt(topic):
    return f"""
Generate multiple-choice questions covering the topic "{topic}". Each question must have exactly four answer options (labeled A, B, C, D). After each question and its options, clearly identify the correct answer. Present the results in this format:

1. Question: [Question text]
   A) [Option A]
   B) [Option B]
   C) [Option C]
   D) [Option D]
   Correct Answer: [Correct Option Letter]
"""

topic = "Nuclear Science"  # <-- change this
prompt = generate_mcq_prompt(topic)
response = model.generate_content(prompt)

print(response.text)

from IPython.display import display, clear_output
import time
import ipywidgets as widgets

def run_quiz(questions_text):
    # Split questions
    questions = questions_text.strip().split("Question: ")[1:]  # skip first empty item

    score =       time.sleep(15)

    print(f"\nüèÅ Quiz Completed! Your Score: {score}/{len(questions)}")

def generate_mcq_prompt(topic):
    return f"""
Generate 5 multiple-choice questions on the topic "{topic}".
Each question must have four options labeled A, B, C, D.
After each question, specify the correct option clearly.

Format:

1. Question: ...
   A) ...
   B) ...
   C) ...
   D) ...
   Correct Answer: B
"""

import re

def parse_questions(response_text):
    pattern = r"\d+\.\s*Question:\s*(.*?)\n\s*A\)\s*(.*?)\n\s*B\)\s*(.*?)\n\s*C\)\s*(.*?)\n\s*D\)\s*(.*?)\n\s*Correct Answer:\s*([ABCD])"
    matches = re.findall(pattern, response_text, re.DOTALL)

    questions = []
    for match in matches:
        question, a, b, c, d, correct = match
        questions.append({
            "question": question.strip(),
            "options": [a.strip(), b.strip(), c.strip(), d.strip()],
            "answer": correct.strip()
        })
    return questions

import ipywidgets as widgets
from IPython.display import display, clear_output
import time
import threading

def run_quiz(questions):
    score = 0
    total = len(questions)

    for i, q in enumerate(questions):
        clear_output(wait=True)
        print(f"üß† Question {i+1} of {total}")
        print(q["question"])

        radio = widgets.RadioButtons(
            options=q["options"],
            layout=widgets.Layout(width='auto'),
            style={'description_width': 'initial'}
        )

        submit_button = widgets.Button(
            description="‚úÖ Submit",
            button_style='success',
            layout=widgets.Layout(width='150px')
        )

        timer_output = widgets.Output()
        result_output = widgets.Output()
        box = widgets.VBox([radio, submit_button, timer_output, result_output])
        display(box)

        answered = threading.Event()

        def handle_submit(_):
            if not answered.is_set():
                selected = radio.value
                with result_output:
                    clear_output()
                    if selected and selected.strip().startswith(q["answer"]):
                        print("‚úÖ Correct!")
                        nonlocal score
                        score += 1
                    else:
                        print(f"‚ùå Incorrect. Correct: {q['answer']}")
                answered.set()

        submit_button.on_click(handle_submit)

        def countdown():
            for t in range(10, 0, -1):
                with timer_output:
                    clear_output(wait=True)
                    print(f"‚è≥ Time left: {t} seconds")
                if answered.wait(1):
                    return
            if not answered.is_set():
                with result_output:
                    clear_output()
                    print(f"‚è±Ô∏è Time's up! Correct: {q['answer']}")
                answered.set()

        timer_thread = threading.Thread(target=countdown)
        timer_thread.start()
        timer_thread.join()  # Wait for the timer to finish
        time.sleep(2)  # Optional delay before next question

    clear_output(wait=True)
    print(f"üèÅ Quiz Completed! Your Score: {score}/{total}")

questions = [
    {
        "question": "Which gas is produced during photosynthesis?",
        "options": [
            "A) Carbon Dioxide",
            "B) Oxygen",
            "C) Nitrogen",
            "D) Hydrogen"
        ],
        "answer": "B"
    },
    {
        "question": "What is the main pigment used in photosynthesis?",
        "options": [
            "A) Chlorophyll",
            "B) Hemoglobin",
            "C) Carotene",
            "D) Xanthophyll"
        ],
        "answer": "A"
    }
]

run_quiz(questions)

# EXAMPLE USAGE
topic = "Artificial Intelligence"
prompt = generate_mcq_prompt(topic)
response = model.generate_content(prompt)
quiz_questions = parse_questions(response.text)
run_quiz(quiz_questions)

import ipywidgets as widgets
from IPython.display import display, clear_output
import random
import google.generativeai as genai

# --- SETUP ---
genai.configure(api_key=MainAPI)

model = genai.GenerativeModel("models/gemini-2.0-flash")

# --- AI-GENERATED QUIZ FUNCTION ---
def generate_quiz(topic):
    prompt = f"""
Generate 5 multiple-choice questions on the topic "{topic}".
Each question must have exactly 4 options (A, B, C, D), and indicate the correct answer.
Format:
Question: ...
A) ...
B) ...
C) ...
D) ...
Correct Answer: ...
"""
    response = model.generate_content(prompt)
    return response.text

# --- PARSE THE QUESTIONS ---
def parse_questions(raw_text):
    questions = []
    blocks = raw_text.strip().split("Question:")
    for block in blocks[1:]:
        lines = block.strip().split("\n")
        q_text = lines[0].strip()
        options = {}
        for line in lines[1:5]:
            if ')' in line:
                key, val = line.split(')', 1)
                options[key.strip()] = val.strip()
        correct = ""
        for line in lines:
            if "Correct Answer:" in line:
                correct = line.split(":")[1].strip()
        questions.append({
            "question": q_text,
            "options": options,
            "answer": correct.upper()
        })
    return questions

# --- QUIZ UI LOGIC ---
class LiveQuiz:
    def __init__(self, topic):
        raw_data = generate_quiz(topic)
        self.questions = parse_questions(raw_data)
        self.current_index = 0
        self.score = 0
        self.answer_input = widgets.Text(description="Your Answer:", placeholder="A/B/C/D")
        self.feedback = widgets.HTML()
        self.next_button = widgets.Button(description="Next")
        self.out = widgets.Output()
        self.answer_input.observe(self.check_answer, names="value")
        self.next_button.on_click(self.next_question)
        self.show_question()

    def show_question(self):
        self.answer_input.value = ""
        self.feedback.value = ""
        clear_output(wait=True)
        self.out.clear_output()
        q = self.questions[self.current_index]
        with self.out:
            print(f"Question {self.current_index + 1}: {q['question']}")
            for key, val in q["options"].items():
                print(f"{key}) {val}")
        display(self.out, self.answer_input, self.feedback, self.next_button)

    def check_answer(self, change):
        user_answer = self.answer_input.value.strip().upper()
        correct = self.questions[self.current_index]["answer"]
        if user_answer not in ["A", "B", "C", "D"]:
            self.feedback.value = "<span style='color:red'>Please enter A, B, C, or D</span>"
            return
        if user_answer == correct:
            self.feedback.value = "<span style='color:green'>‚úÖ Correct!</span>"
            self.score += 1
        else:
            self.feedback.value = f"<span style='color:red'>‚ùå Incorrect. Correct answer: {correct}</span>"

    def next_question(self, btn):
        self.current_index += 1
        if self.current_index < len(self.questions):
            self.show_question()
        else:
            clear_output()
            print(f"üèÅ Quiz Completed! Your Score: {self.score}/{len(self.questions)}")

# --- RUN THE QUIZ ---
topic = "Artificial Intelligence"  # or change to any topic!
LiveQuiz(topic)

!pip install google-generativeai

import ipywidgets as widgets
from IPython.display import display, clear_output
import google.generativeai as genai
import threading
import time

# Configure the Gemini API
genai.configure(api_key=MainAPI)  # üîë Replace with your actual API key
model = genai.GenerativeModel("models/gemini-2.0-flash")

class LiveQuizWithTimer:
    def __init__(self, topic, time_limit=15):
        self.topic = topic
        self.time_limit = time_limit
        self.questions = self.generate_quiz_questions()
        self.current_index = 0
        self.score = 0
        self.timer_running = False
        self.user_input = widgets.Text(description="Your Answer:")
        self.submit_button = widgets.Button(description="Submit")
        self.output_area = widgets.Output()
        self.timer_label = widgets.Label()
        self.display_widgets()

    def generate_quiz_questions(self):
        prompt = f"""Generate 5 multiple-choice quiz questions on the topic "{self.topic}".
Each question should have 4 options labeled A-D, and indicate the correct answer in this format:

Q: What is the function of chlorophyll?
A. Stores water
B. Absorbs sunlight
C. Transports minerals
D. Protects the leaf
Answer: B

Only include questions, options, and answers in this format."""

        response = model.generate_content(prompt)
        text = response.text

        questions = []
        blocks = text.strip().split("Q:")
        for block in blocks:
            if not block.strip():
                continue
            lines = block.strip().split("\n")
            question_text = lines[0].strip()
            options = [line.strip() for line in lines[1:5]]
            answer_line = [line for line in lines if "Answer:" in line]
            if not answer_line:
                continue
            answer = answer_line[0].split(":")[-1].strip().upper()
            questions.append({
                "question": question_text,
                "options": options,
                "answer": answer
            })
        return questions

    def display_widgets(self):
        display(self.output_area, self.timer_label, self.user_input, self.submit_button)
        self.submit_button.on_click(self.check_answer)
        self.show_question()
        self.start_timer()

    def show_question(self):
        with self.output_area:
            clear_output()
            q = self.questions[self.current_index]
            print(f"Q{self.current_index + 1}: {q['question']}")
            for opt in q["options"]:
                print(opt)

    def start_timer(self):
        self.timer_running = True
        thread = threading.Thread(target=self.run_timer)
        thread.start()

    def run_timer(self):
        seconds = self.time_limit
        while seconds > 0 and self.timer_running:
            self.timer_label.value = f"‚è≥ Time Left: {seconds} sec"
            time.sleep(1)
            seconds -= 1
        if self.timer_running:
            self.check_answer(None)

    def check_answer(self, b):
        if self.current_index >= len(self.questions):
            return
        self.timer_running = False
        user_ans = self.user_input.value.strip().upper()
        correct = self.questions[self.current_index]["answer"]
        is_correct = user_ans == correct
        feedback = f"‚úÖ Correct!" if is_correct else f"‚ùå Wrong! Correct Answer: {correct}"

        if is_correct:
            self.score += 1
        self.current_index += 1

        with self.output_area:
            clear_output()
            print(feedback)
            time.sleep(1.5)

        if self.current_index < len(self.questions):
            self.user_input.value = ""
            self.show_question()
            self.start_timer()
        else:
            with self.output_area:
                clear_output()
                print("üèÅ Quiz Completed!")
                print(f"‚úÖ Your Final Score: {self.score}/{len(self.questions)}")

# üî• Run the Quiz
topic = "Photosynthesis"  # Replace with any topic
quiz = LiveQuizWithTimer(topic, time_limit=20)

# --- RUN THE QUIZ ---
topic = "Artificial Intelligence"  # Replace with any topic
LiveQuizWithTimer(topic, time_limit=20)

!pip install -q google-generativeai ipywidgets

# üìå Step 1: Install and import required libraries


import google.generativeai as genai
import ipywidgets as widgets
from IPython.display import display, clear_output
import time

# üìå Step 2: Configure Gemini API Key (replace with your key)
genai.configure(api_key=MainAPI)  # <--- üîë Replace this with your actual API key

# üìå Step 3: User Input
num_questions = int(input("Enter number of questions: "))
topic = input("Enter quiz topic: ")
time_limit = int(input("Enter time limit per question (in seconds): "))

# üìå Step 4: Generate Questions using Gemini API
def generate_quiz_questions(topic, num_questions):
    prompt = f"""
Generate {num_questions} multiple-choice questions on the topic '{topic}'.
Each question should have 4 options labeled A, B, C, D.
Mark the correct answer clearly.

Format:
Q: Question text
A. Option A
B. Option B
C. Option C
D. Option D
Answer: A/B/C/D
"""
    try:
        model = genai.GenerativeModel("models/gemini-2.0-flash")
        response = model.generate_content(prompt)
        raw_text = response.text.strip()
        return parse_questions(raw_text)
    except Exception as e:
        print("‚ùå Gemini API failed. Loading fallback questions instead.")
        # üëá Provide some fallback questions if Gemini fails
        return [
            {
                "question": "Who won the first IPL tournament?",
                "options": {"A": "Chennai Super Kings", "B": "Rajasthan Royals", "C": "Mumbai Indians", "D": "RCB"},
                "answer": "B"
            },
            {
                "question": "Which Indian cricketer is known as 'Captain Cool'?",
                "options": {"A": "Virat Kohli", "B": "Rohit Sharma", "C": "MS Dhoni", "D": "Kapil Dev"},
                "answer": "C"
            },
            {
                "question": "What is the maximum number of players in a cricket team?",
                "options": {"A": "9", "B": "10", "C": "11", "D": "12"},
                "answer": "C"
            },
        ][:num_questions]  # limit to requested number


# üìå Step 5: Parse Gemini Output
def parse_questions(raw_text):
    questions = []
    blocks = raw_text.split("Q:")[1:]  # Skip anything before first question
    for block in blocks:
        lines = block.strip().split("\n")
        q_text = lines[0].strip()
        options = {}
        for line in lines[1:5]:
            key, val = line.split(".", 1)
            options[key.strip()] = val.strip()
        answer_line = [line for line in lines if "Answer:" in line]
        answer = answer_line[0].split("Answer:")[1].strip() if answer_line else ""
        questions.append({"question": q_text, "options": options, "answer": answer})
    return questions

# üìå Step 6: Display Quiz with Timer
def start_quiz(questions, time_limit):
    score = 0
    for i, q in enumerate(questions):
        clear_output(wait=True)
        print(f"üîπ Question {i+1}/{len(questions)}")
        print(q['question'])
        for key, val in q['options'].items():
            print(f"{key}. {val}")

        # Create input widget
        answer_box = widgets.Text(
            placeholder='Enter A, B, C, or D',
            description='Answer:',
            style={'description_width': 'initial'}
        )
        submit_button = widgets.Button(description="Submit")
        output = widgets.Output()

        user_answer = {"value": None}

        def on_submit(b):
            ans = answer_box.value.strip().upper()
            if ans in ['A', 'B', 'C', 'D']:
                user_answer['value'] = ans
            else:
                with output:
                    clear_output()
                    print("‚ùå Invalid input. Please enter A, B, C, or D.")

        submit_button.on_click(on_submit)

        display(answer_box, submit_button, output)

        # Timer loop
        start_time = time.time()
        while time.time() - start_time < time_limit:
            if user_answer["value"] is not None:
                break
            time.sleep(0.1)

        # Result evaluation
        clear_output(wait=True)
        print(f"üîπ Question {i+1}/{len(questions)}")
        print(q['question'])
        for key, val in q['options'].items():
            print(f"{key}. {val}")

        if user_answer["value"] is None:
            print("‚è∞ Time's up!")
            print(f"‚ùå Correct answer was: {q['answer']}")
        else:
            print(f"‚úÖ You answered: {user_answer['value']}")
            if user_answer['value'] == q['answer']:
                print("üéâ Correct!")
                score += 1
            else:
                print(f"‚ùå Incorrect. Correct answer was: {q['answer']}")

        time.sleep(2)

    print("\nüèÅ Quiz Finished!")
    print(f"Your Score: {score}/{len(questions)}")


# üìå Step 7: Run Everything
questions = generate_quiz_questions(topic, num_questions)
if questions:
    start_quiz(questions, time_limit)
else:
    print("‚ùå Quiz could not be generated.")

